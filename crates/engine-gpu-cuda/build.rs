use std::env;
use std::ffi::OsStr;
use std::fs;
use std::io::{self};
use std::path::{Path, PathBuf};
use std::process::Command;

/// Build script to compile CUDA kernels (.cu) to PTX when the `cuda` feature is enabled on this crate.
/// - Scans common kernel directories (`src/kernels`, `src/cuda`) for `.cu` files
/// - Uses `nvcc` to compile each `.cu` into a `.ptx` artifact under `$OUT_DIR`
/// - Emits cargo rebuild hints (`rerun-if-changed`) for all discovered `.cu` files
///
/// Configuration (environment variables):
/// - CARGO_FEATURE_CUDA: Automatically set by Cargo when this crate is built with `features = ["cuda"]`
/// - NVCC: Optional explicit path to the `nvcc` binary
/// - CUDA_HOME or CUDA_PATH: If set, used to derive the default `nvcc` path (`$CUDA_HOME/bin/nvcc`)
/// - CUDA_ARCH: Target architecture for PTX generation (default: "sm_70")
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Only do CUDA work if this crate is built with the `cuda` feature.
    // Cargo sets CARGO_FEATURE_<FEATURE_NAME_UPPERCASE> for the current crate.
    let cuda_feature_enabled = env::var_os("CARGO_FEATURE_CUDA").is_some();
    println!("cargo:rerun-if-env-changed=CARGO_FEATURE_CUDA");

    if !cuda_feature_enabled {
        // No CUDA feature on this crate; nothing to do.
        println!("cargo:warning=engine-gpu-cuda built without 'cuda' feature; skipping kernel compilation.");
        return Ok(());
    }

    // Gather kernel sources (.cu) from common locations
    let kernel_roots = [
        Path::new("src").join("kernels"),
        Path::new("src").join("cuda"),
    ];

    let mut cu_files: Vec<PathBuf> = Vec::new();
    for root in kernel_roots.iter() {
        if root.is_dir() {
            scan_cu_files(root, &mut cu_files)?;
        }
    }

    // If there are no kernels yet, still generate an empty bindings file so include! compiles.
    if cu_files.is_empty() {
        let out_dir = PathBuf::from(env::var("OUT_DIR")?);
        let bindings_path = out_dir.join("ptx_bindings.rs");
        let mut rs = String::new();
        rs.push_str("// @generated by engine-gpu-cuda/build.rs — DO NOT EDIT MANUALLY\n");
        rs.push_str("#[allow(dead_code)]\n");
        rs.push_str(
            "pub mod ptx_embedded { pub fn get(_: &str) -> Option<&'static str> { None } }\n\
             pub mod cubin_embedded { pub fn get_cubin(_: &str) -> Option<&'static [u8]> { None } }\n",
        );
        std::fs::write(&bindings_path, rs)?;
        println!(
            "cargo:rustc-env=ENGINE_GPU_CUDA_PTX_DIR={}",
            out_dir.display()
        );
        println!("cargo:warning=No CUDA kernels (.cu) found; generated empty PTX bindings.");
        return Ok(());
    }

    // Emit rebuild hints for kernels and config env vars that affect compilation
    for cu in &cu_files {
        println!("cargo:rerun-if-changed={}", cu.display());
    }
    println!("cargo:rerun-if-env-changed=NVCC");
    println!("cargo:rerun-if-env-changed=CUDA_HOME");
    println!("cargo:rerun-if-env-changed=CUDA_PATH");
    println!("cargo:rerun-if-env-changed=CUDA_ARCH");

    // Determine nvcc path
    let nvcc = find_nvcc().ok_or_else(|| {
        io::Error::new(
            io::ErrorKind::NotFound,
            "Unable to locate `nvcc`. Set NVCC or CUDA_HOME/CUDA_PATH, or ensure nvcc is in PATH.",
        )
    });

    let nvcc = match nvcc {
        Ok(p) => p,
        Err(e) => {
            eprintln!("cargo:warning={}", e);
            eprintln!(
                "cargo:warning=Skipping CUDA kernel compilation; generating empty PTX bindings."
            );
            let out_dir = PathBuf::from(env::var("OUT_DIR")?);
            let bindings_path = out_dir.join("ptx_bindings.rs");
            let mut rs = String::new();
            rs.push_str("// @generated by engine-gpu-cuda/build.rs — DO NOT EDIT MANUALLY\n");
            rs.push_str("#[allow(dead_code)]\n");
            rs.push_str(
                "pub mod ptx_embedded { pub fn get(_: &str) -> Option<&'static str> { None } }\n\
                 pub mod cubin_embedded { pub fn get_cubin(_: &str) -> Option<&'static [u8]> { None } }\n",
            );
            std::fs::write(&bindings_path, rs)?;
            println!(
                "cargo:rustc-env=ENGINE_GPU_CUDA_PTX_DIR={}",
                out_dir.display()
            );
            return Ok(());
        }
    };

    // Architecture (SM version) can be overridden; default to sm_70 as a reasonable baseline for modern GPUs
    let raw_arch = env::var("CUDA_ARCH").unwrap_or_else(|_| "sm_70".to_string());
    // Normalize to a compute/sm pair:
    // - Use compute_* for -arch
    // - Use sm_* for -code
    let (arch_compute, arch_sm) = if let Some(s) = raw_arch.strip_prefix("sm_") {
        (format!("compute_{}", s), raw_arch.clone())
    } else if let Some(s) = raw_arch.strip_prefix("compute_") {
        (raw_arch.clone(), format!("sm_{}", s))
    } else {
        // Fallback: assume input is an sm_*; derive compute_* accordingly when possible
        if let Some(s) = raw_arch.strip_prefix("sm") {
            (format!("compute{}", s), raw_arch.clone())
        } else {
            // Default baseline
            ("compute_70".to_string(), "sm_70".to_string())
        }
    };

    // Output directory for PTX artifacts
    let out_dir = PathBuf::from(env::var("OUT_DIR")?);
    // Also expose the PTX directory to the crate if desired
    println!(
        "cargo:rustc-env=ENGINE_GPU_CUDA_PTX_DIR={}",
        out_dir.display()
    );

    // Compile each .cu into artifacts
    // - PTX: for driver JIT (fallback)
    // - FATBIN: native SASS per-SM (preferred; avoids PTX JIT/ISA mismatches)
    // Collect generated artifact paths to produce an embedded Rust module for runtime inclusion.
    let mut generated_ptx: Vec<(String, PathBuf)> = Vec::new();
    let mut generated_cubin: Vec<(String, PathBuf)> = Vec::new();
    for cu in &cu_files {
        let stem = cu
            .file_stem()
            .and_then(OsStr::to_str)
            .ok_or_else(|| io::Error::new(io::ErrorKind::Other, "Invalid kernel filename"))?
            .to_string();

        let ptx_path = out_dir.join(format!("{stem}.ptx"));
        let cubin_path = out_dir.join(format!("{stem}.cubin"));

        // PTX
        match compile_to_ptx(&nvcc, &arch_compute, cu, &ptx_path) {
            Ok(()) => {
                println!(
                    "cargo:warning=nvcc PTX OK: {} -> {}",
                    cu.display(),
                    ptx_path.display()
                );
                generated_ptx.push((stem.clone(), ptx_path.clone()));
            }
            Err(err) => {
                eprintln!("cargo:warning=nvcc PTX failed for {}: {err}", cu.display());
                eprintln!(
                    "cargo:warning=Skipping PTX for {} (will rely on FATBIN if available)",
                    stem
                );
            }
        }

        // CUBIN (preferred at runtime)
        match compile_to_cubin(&nvcc, &arch_compute, &arch_sm, cu, &cubin_path) {
            Ok(()) => {
                println!(
                    "cargo:warning=nvcc CUBIN OK: {} -> {}",
                    cu.display(),
                    cubin_path.display()
                );
                generated_cubin.push((stem, cubin_path.clone()));
            }
            Err(err) => {
                eprintln!(
                    "cargo:warning=nvcc FATBIN failed for {}: {err}",
                    cu.display()
                );
                eprintln!(
                    "cargo:warning=nvcc CUBIN failed for {}: {err}",
                    cu.display()
                );
                eprintln!(
                    "cargo:warning=Skipping CUBIN for {} (will fall back to PTX if present)",
                    stem
                );
            }
        }
    }

    // Generate an embedded PTX/FATBIN bindings file so the crate can include!() the artifacts at compile time.
    // This avoids needing ENGINE_GPU_CUDA_PTX_DIR at runtime for the common case.
    // Output: $OUT_DIR/ptx_bindings.rs with:
    //   - pub mod ptx_embedded { pub const QPOW_KERNEL_PTX: &str = "..."; pub fn get_ptx(name: &str) -> Option<&'static str>; pub fn get(name: &str) -> Option<&'static str>; }
    //   - pub mod cubin_embedded { pub static QPOW_KERNEL_CUBIN: &'static [u8] = &[…]; pub fn get_cubin(name: &str) -> Option<&'static [u8]>; }
    let bindings_path = out_dir.join("ptx_bindings.rs");
    let mut rs = String::new();
    rs.push_str("// @generated by engine-gpu-cuda/build.rs — DO NOT EDIT MANUALLY\n");
    rs.push_str("#[allow(dead_code)]\n");

    // PTX module (string)
    rs.push_str("pub mod ptx_embedded {\n");

    for (stem, path) in &generated_ptx {
        let const_name = stem
            .chars()
            .map(|c| {
                if c.is_ascii_alphanumeric() {
                    c.to_ascii_uppercase()
                } else {
                    '_'
                }
            })
            .collect::<String>()
            + "_PTX";
        let ptx = std::fs::read_to_string(path).unwrap_or_else(|_| String::new());
        rs.push_str(&format!("    pub const {}: &str = r###\"", const_name));
        rs.push_str(&ptx);
        rs.push_str("\"###;\n");
    }

    rs.push_str("    pub fn get_ptx(name: &str) -> Option<&'static str> {\n");
    rs.push_str("        match name {\n");
    for (stem, _) in &generated_ptx {
        let const_name = stem
            .chars()
            .map(|c| {
                if c.is_ascii_alphanumeric() {
                    c.to_ascii_uppercase()
                } else {
                    '_'
                }
            })
            .collect::<String>()
            + "_PTX";
        rs.push_str(&format!(
            "            \"{}\" => Some({}),\n",
            stem, const_name
        ));
    }
    rs.push_str("            _ => None,\n");
    rs.push_str("        }\n");
    rs.push_str("    }\n");
    // Backwards-compatible alias expected by current loader
    rs.push_str("    pub fn get(name: &str) -> Option<&'static str> { get_ptx(name) }\n");
    rs.push_str("}\n");

    // CUBIN module (bytes)
    rs.push_str("pub mod cubin_embedded {\n");

    for (stem, path) in &generated_cubin {
        let const_name = stem
            .chars()
            .map(|c| {
                if c.is_ascii_alphanumeric() {
                    c.to_ascii_uppercase()
                } else {
                    '_'
                }
            })
            .collect::<String>()
            + "_CUBIN";
        let bytes = std::fs::read(path).unwrap_or_default();
        // Render as byte array
        rs.push_str(&format!(
            "    pub static {}: &'static [u8] = &[\n        ",
            const_name
        ));
        for (i, b) in bytes.iter().enumerate() {
            if i > 0 && i % 16 == 0 {
                rs.push_str("\n        ");
            }
            rs.push_str(&format!("{},", b));
        }
        rs.push_str("\n    ];\n");
    }

    rs.push_str("    pub fn get_cubin(name: &str) -> Option<&'static [u8]> {\n");
    rs.push_str("        match name {\n");
    for (stem, _) in &generated_cubin {
        let const_name = stem
            .chars()
            .map(|c| {
                if c.is_ascii_alphanumeric() {
                    c.to_ascii_uppercase()
                } else {
                    '_'
                }
            })
            .collect::<String>()
            + "_CUBIN";
        rs.push_str(&format!(
            "            \"{}\" => Some({}),\n",
            stem, const_name
        ));
    }
    rs.push_str("            _ => None,\n");
    rs.push_str("        }\n");
    rs.push_str("    }\n");
    rs.push_str("}\n");

    std::fs::write(&bindings_path, rs)?;

    // Keep the old env for fallback or external loaders if needed.
    println!(
        "cargo:rustc-env=ENGINE_GPU_CUDA_PTX_DIR={}",
        out_dir.display()
    );

    Ok(())
}

fn scan_cu_files(root: &Path, out: &mut Vec<PathBuf>) -> io::Result<()> {
    for entry in fs::read_dir(root)? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            scan_cu_files(&path, out)?;
        } else if path.extension().and_then(OsStr::to_str) == Some("cu") {
            out.push(path);
        }
    }
    Ok(())
}

fn find_nvcc() -> Option<PathBuf> {
    // 1) Explicit override
    if let Some(p) = env::var_os("NVCC") {
        let pb = PathBuf::from(p);
        if pb.is_file() {
            return Some(pb);
        }
    }

    // 2) CUDA_HOME or CUDA_PATH
    if let Some(home) = env::var_os("CUDA_HOME").or_else(|| env::var_os("CUDA_PATH")) {
        let mut candidate = PathBuf::from(home);
        candidate.push("bin");
        candidate.push(exe("nvcc"));
        if candidate.is_file() {
            return Some(candidate);
        }
    }

    // 3) PATH lookup — try invoking `nvcc --version`
    if let Ok(output) = Command::new("nvcc").arg("--version").output() {
        if output.status.success() {
            return Some(PathBuf::from("nvcc"));
        }
    }

    None
}

fn compile_to_ptx(nvcc: &Path, arch: &str, src: &Path, out: &Path) -> io::Result<()> {
    // Ensure parent directory exists
    if let Some(parent) = out.parent() {
        fs::create_dir_all(parent)?;
    }

    // Example command:
    //   nvcc -ptx -arch=sm_70 -o <OUT_DIR>/kernel.ptx <src.cu>
    let status = Command::new(nvcc)
        .args(["-ptx", "-arch", arch])
        .arg("-o")
        .arg(out)
        .arg(src)
        .status()?;

    if !status.success() {
        return Err(io::Error::new(
            io::ErrorKind::Other,
            format!("nvcc returned non-zero exit status (ptx): {status}"),
        ));
    }

    Ok(())
}

/// Compile a native CUBIN (SASS) for the specified SM arch. Preferred at runtime to avoid PTX JIT.
fn compile_to_cubin(
    nvcc: &Path,
    arch_compute: &str,
    arch_sm: &str,
    src: &Path,
    out: &Path,
) -> io::Result<()> {
    // Ensure parent directory exists
    if let Some(parent) = out.parent() {
        fs::create_dir_all(parent)?;
    }

    // Example command:
    //   nvcc -cubin -arch=sm_86 -code=sm_86 -o <OUT_DIR>/kernel.cubin <src.cu>
    // For compute_* inputs, pass through to -arch and let nvcc select appropriate code.
    let status = Command::new(nvcc)
        .args(["-cubin", "-arch", arch_compute, "-code", arch_sm])
        .arg("-o")
        .arg(out)
        .arg(src)
        .status()?;

    if !status.success() {
        return Err(io::Error::new(
            io::ErrorKind::Other,
            format!("nvcc returned non-zero exit status (cubin): {status}"),
        ));
    }

    Ok(())
}

#[cfg(target_os = "windows")]
fn exe(name: &str) -> String {
    format!("{name}.exe")
}

#[cfg(not(target_os = "windows"))]
fn exe(name: &str) -> String {
    name.to_string()
}
